在本地创建一个与github名字相同的repo，之后的步骤是：
echo "# GoEleven" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/lucyyangruo/GoEleven.git
git push -u origin main
——官方指导
## 相关解释
1. 修改文件先add，再commit，再push
2. git branch -M main 的意思是新建一个main分支，然后将本地的操作移动到main上，move，在main上继续执行命令。
3. git remote add origin 的意思是建立一个远程git仓库，并命令为origin，这里的仓库要注意是 http的形式，建议采用ssh的方式，因为之前已经在本地通过ssh的形式进行关联。
这里我就使用了http，所以导致一直没法push。之后通过 git remote -v 查看关联的仓库
通过 git remote set-url origin ssh.. 来修改仓库，再进行push 成功
4. 原来我已经在known_host文件中添加了github的密钥，而昨天进行了重新生成了新的密钥，并与远程相关联，所以一直提示密钥不对，修改步骤：删除旧的主机密钥：ssh-keygen -R github.com ，重新添加新的主机密钥：ssh -T git@github.com  ，之后就可以进行push了。

以上就是我的步骤解释和遇到的问题。

## 修改文件提交到远程
git add --all 
git commit -m "desc"
git push
## 相关解释
1. 这里使用的是git push，而不是上面的git push -u main。-u是设置上游分支，并制定与本地分支的关联关系，upstream，即使上游分支中不存在main，也会关联成功。同 git push -u origin main 相同。
2. 使用git branch -r 查看所有的远程分支

## 39课程：
checksum：Checksum（校验和）是一种用于验证文件完整性的方法。它通过对文件数据进行数学运算生成一个唯一的值，当文件内容发生变化时，这个值也会发生变化。

是一个技术，使用不同数学算法——md5、sha-256等得到的值也称为checksum value
根据文件内容将会生成唯一的值，一般用在网络协议——TCP/IP，或者文件传输协议上——FTP/HTTP。为了确保准确性和安全性

安装go——可以在官网上下载，也可通过homwbrew来安装

## 40课程
安装go
：使用homebrew安装，需配置环境变量，设置GOPATH——在 Go 中，GOPATH 是一个用于存储 Go 项目和依赖包的工作区目录。然而，从 Go 1.11 版本开始，引入了 Go Modules，这改变了 Go 项目的组织和管理方式。
因此我按照默认方式配置go路径，开启强制module管理。设置 GO111MODULE=on 强制启用模块支持：

安装vscode

## 41课程
go 在vs中编写，执行命令等方式
1. 首先需要定义一个module，在每个go项目下必须有个go module-初始化go模块：go mod init github.com/GoesToEleven/animalPackage
tip： 类似：使用git init 来初始化git仓库，也就是将当前目录设置为git 仓库，会在当前目录下创建一个隐藏文件.git
        关于module，是必须以域名开头，表示将该模块托管在该平台下，以确保唯一性。
        而package main是定义程序可执行入口的唯一路径，pkg main下必须有一个func main。
2. 创建一个go file。文件夹名就是pkg名称，每个pkg下的文件名必须有相同的pkg名称。
3. 执行go程序-在shell中使用go run main.go 来执行主程序，或者-go run ./... 来运行所有程序，在当前目录下
    或者-也可以使用go build 来构建一个可执行程序，再运行，会给一个.exe文件，执行./animalPackage.exe即可
    或者-交叉编译，也就是win系统下为mac/linux编译可程序文件，使用GOOS=darwin go build 这是为了mac来构建的，可以看到输出一个文件是mac的可执行文件。
    like-GOOS=darwin/linux/windows go build
4. 使用 go env GOARCH GOOS 来查看当前的架构和操作系统，like显示 amd64 windows
5. 使用go version 查看版本
6. 使用 go help 查看命令帮助
7. 使用 go env 来查看你所有的go环境变量
    其中：go root是go语言的核心二进制文件所存的帝制
        go path是bin包和源代码地址


## 42课程
使用go install 就是将当前目录下的go文件进行构建成二进制文件，并放入到go path的bin目录下。

## 43课程
write code with errors before write code without errors
了解module、pkg、dependency、创建工作区的变化、name spacing、等概念

## 44课程
1. 意大利面条式代码——杂乱无章、难以理解、非结构化、无法重用
2. 模块化代码/结构化编程——模块化代码是结构化编程的一个方面，结构化编程是一种软件开发方法，是一般准则，但有时可以不尊循，因为代码的清晰性高于简洁性。
    not DRY-不要重复写自己的代码。将代码任务分为小的、详细设计的、可管理的、可重用的、独立的组建或者模块。模块之间相互协作来实现基本功能。、
3. 依赖关系——就是我导入了第三方的代码，一般对于标准库的代码不算在依赖关系中，standard library。
    分为直接依赖和间接依赖，直接就是a导入了b之间的关系，间接就是a导入了b，b又导入了c，a与c之间的关系。
4. go mod go的工具之一——帮我们配置工作区，也帮我们管理依赖关系
5. go get go的工具之一——允许我们得到第三方依赖关系的内容
6. 一篇文章：依赖的风险和安全漏洞

## 47课程
所以总结：标识符的第一次字母是否大写决定了是否在包外可见，capitalise
任何语言都有其各自的说法，比如描述外部包可不可用其包的变量等，有些语言使用public or private，但在go中使用，a is visible, a is not visible,或者是 a is exported, a is not exported
如果一个go文件中定义的变量是小写开头的，表示他是在包外部不可见，is not visible,not exported
包括pkg内的func的定义名称，identify的第一个字母是否大写
如果是大写的话，就可以在外部包直接用，包名.方法名去使用

but：但是我注意到，如果一个变量名是小写的话，在包内是可以互相调用的，虽然在包外是不能用的，但是通过一个大写的方法来调用这个not visible变量，从而也可以在外部包使用


## 48课程
关于实践module的导入
要求：创建一个module，放到github上，可以方便others来导入，再本地创建一个pkg来导入这个module。
补充，go get时可以在模块名后面加@latest，来导入最新的内容
使用go get后会downlading最新版本，通过-哈希值来判断


创建的module是puppyCopy，不在同一个目录下，https://github.com/lucyyangruo/puppyCopy
在这个module中没有main.go，只有pkg 是puppyCopy和 puppyCopy.go文件

再当前目录下创建一个新的module，因为主目录是annimalPackage，且当前目录下有go.mod文件，表示这是一个module，所以新建一个目录048-modularCode表示一个pkg，里面有main.go主文件。
在里面要使用导入的puppyCopy mudule，所以先在shell中go get module名称，对应mod文件会有所改变，再到要使用的go文件中import module名称，最后即可使用大写表示标识的内容。
最后通过 go mod tidy 来整理mod文件。

使用go mod init进行模块初始化后，会推荐你使用 go mod tidy。
这里解释下关于module 和 package,module是一个模块，一般会用于完成特定的任务，是一系列pkg的集合，一般命名是域名/名字。
pkg是一些列路径地址的集合，跟文件夹名有关，一般不能命名为main、all、cmd、std等容易有歧义的名字


## 49课程
关于实践module的导入
要求：创建一个新的module不同于上面的a，在a中使用这个新的module，并在本地的pkg中来使用这个最新的amodule
补充，关于go get @latest 并不一定能够获取到最新版本，如果有问题的话则可以通过@哈希值 来获取

实践中遇到的主要问题就是 go get @latest 无法获取最新版本-改为哈希值获取。
关于a使用b，b使用c，的这样一种依赖，在a导入b时，也会将c导入到a中

## 51课程
50是对tag课程的overview。
tag是对当前工作目录/repo进行赋予一个标签，指定一个特别的版本。方便日后追踪该版本的改变和队友之间的合作。
一般我们通过v1.0.0开始，其中1是主要的，可以提交changes，但是不可以向后（向老的）版本兼容。0是次要的，可以changes，也可以向后兼容。0是patch补丁，用于changes和向后兼容。

51 先进行git add ，再进行git tag v1.0.0 ，之后可以进行commit-push，就可以查看git tag（表示列出所有的tag），可以使用git show v1.0.0查看该版本信息，主要是修改了哪些内容，跟commit相关
52 在puppyCopy中进行测试，首先git add - commit - push，再进行设置tag git tag v1.0.0，再进行 git push origin --tags.
我出现的错误主要在，在还没有push之前，就进行了git tag v1.0.0 导致push之后，在remote中查看该版本对应下的代码，并没有提交到这，只会出现在没有配置tag的主内容上。所以我在后续增加了 v1.3.1这个tag，才可以将最新的代码配置上tag。
我理解的tag和branch的关系是：一个branch下可以配置多个tag，相当于不同定义的内容在一个分支下体现。
注意：先push代码-在配置tag，- push
53 使用go get @version
在老师的视频中是：使用@latest，获取到的是v1.0.0版本，但是最新的 v1.3.0，所以没办法获取最新的。
但是我实际操作起来可以。
go get使用不同的版本时，也只能使用不同的功能。

注意tip：但是在视频中使用了v1.0.0来编写功能，但是在远程repo是删除了这个版本，也就是在最新的远程代码中是没有该功能，但是依然可以执行，说明这个commit仍然存在于某个地方。
    可以用在git错误删除的情况下。

quote：when the book and bird differ, believe the bird.不要总是相信教程

## 53课程
tip：在vs中移动当前行，向上/向下。使用alt+箭头，对应mac是option+箭头
    复制当前行是，alt+shift+箭头，对应mac是option
    删除当前行是，control+shift+K。
    选中多个相同的内容是，先选择某一内容，再ctrl+d，就会自动把下一个内容，选择上。按两字会选择住下下一个相同的内容，以此类推
    竖向选择时，选中alt，mac是option。
练习1:在一个func内使用两个func外定义的变量，一个使用var定义，一个使用const定义常量。
实践总结： 使用printf可以输出%v %t这些的表示内容。
    对于字符串可以使用 ""+ a + 的形式来输出，但是对于int这些类型就不能使用+ 的格式。
    需要使用 先定义号要输出的内容规范，在通过 , a,b 来输出值。
    🤔：如何使用052-hands-exer内的内容运行，main和其他pkg如何定义

## 54课程
练习2:使用terminal来创建go workspace，再写个hello 世界
实践总结：如果你创建的代码目录是在已经存在go.mod文件下，那么就不需要go mod init
tip：使用nano编辑时，buffer 是一个存储区内存。

## 55课程
联系3:build上面这个项目，再运行可执行文件executable。
实践总结：使用go build main.go 编译go程序，或者使用 go build . 使用 ./053-hands-exer 来运行主程序
        关于可执行文件的名字产生原因：
            在Go编程语言中，使用go build命令编译程序时，如果没有指定输出文件名，默认生成的可执行文件会使用当前目录的名字作为文件名。
            这是Go的一种默认行为。为了避免这种情况并指定生成的可执行文件名，无论在哪个平台上，你可以使用-o选项。
            go build -o myprogram main.go
            **
            在 Windows 上，go build main.go 生成 main.exe
            在 Unix 系统上，go build main.go 生成 main
            在 Unix 系统上，如果运行 go build 而不指定源文件，生成的可执行文件名将是当前目录的名字。
            同样适用 go build ./... 也会生成当前目录名字

## 56课程
练习4:为不同操作系统构建不同可执行文件
实践总结：for windows ：GOOS=windows go build main.go ，不加main.go就产生主目录名的exe文件
        for mac（本身是mac也可以使用）：GOOS=darwin go build
        for linux：GOOS=linux go build 产生的executable同mac相同

## 57课程
练习5:使用go install来安装程序，观察gopath/bin下的内容
实践总结：主要是使用install编译并安装程序，在go的某一版本更新后，实行module管理项目，就不需要讲go项目放在gopath/src目录下了。
        在主目录下执行go install 无需要可执行文件名字。
        在gopath/bin就会出现可执行程序，名字同可执行文件名相同，——查看gopath %中，GOPATH,就会主动跳转到当前目录
        表示其在任何地方都可以方便地运行，不在bin目录也可以运行.使用053-hands-exer或者./053-hands-exer都可以运行
        
## 58课程
练习6:查看github上的puppy仓库与本地的区别，运行go mod tidy,了解这个命令是做什么的
实践总结：与远程相同，但是使用tidy，发现“indirect”消失，间接引用没有了
练习补充：引用puppy的内容，在059目录下
实践总结：在创建mod之后，引用包之后，使用时要注意，一直提示没有导入该pkg，需要重命名一下，多次尝试go mod tidy。
        再重命名包名，使用全部小写定义


## 59课程
练习7:使用puppy的打印version
实践总结：由于我之前定义puppycopy的showversion没有使用大写，🍁注意：即使go get了也不能使用小写定义的变量。
        因此重新定义了方法来实现这一功能。
        所以重新创建提交tag标签。🍁注意区分tag和branch的区别：
            tag是静态的，表示对某一次提交进行标记，比如版本发布时标注某一版本，等情况。tag类似一个指针永远制定的标注的这一内容，不会更新。
            branch是动态的，表示提交的状态，在当前分支下每次提交都会更新，branch的状态永远是最新的。
                「
                标签：是指向某个特定提交的指针，用于标记重要的版本。标签不会随着新的提交而移动。
                分支：是一个移动的指针，指向仓库的最新提交。推送代码时，你是推送到分支而不是标签。
                推送命令并不会影响已有的标签，除非你显式地推送或删除标签。
                」
            在推送代码时，先commit代码，再创建一个tag（需要的话），再push代码，再push tag。
                「
                在Git中，一般的工作流程是先进行代码提交（commit），然后基于特定的提交创建标签（tag）。标签是对某个特定提交的引用，因此需要有提交对象存在，才能创建标签。
                # 推送当前分支的提交
                git push origin main
                # 推送所有标签
                git push origin --tags
                # 查看tag内
                git show v1.0.0
                # 创建带注释的tag
                git tag -a v1.0.0 -m "Release version 1.0.0"
                」
            创建有注释的tag，主要用于作者、实践、内容等信息。更安全。
                「
                带注释的标签是对象存储在Git数据库中的独立对象，因此在版本控制中更加稳健。
                」
        之后在059中可以使用showversion的内容。


## 60课程
练习8:依赖之前的tag v1.2.0，检查go.mod文件

## 61课程
练习8:创建一个新的仓库repo，提交内容并创建tag。
实践总结：将当前目录的修改进行提交，并创建一个tag。
        「
        换句话说，如果你从创建仓库起一直没有创建任何标签，那么仓库中就不会有任何标签。
        Git也不会假设或默认使用 v1.0.0 或任何其他标签。
        」
















